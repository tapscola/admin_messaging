<?php
// $Id$
/**
* @file
* This module provides messaging interface for administrators.
* Using this module, administrators can send email to a user from the
* user's "view" page.
*/
 
/**
 * implementation of hook_help()
 */
 // Method with push delivery. Messages will be pushed to the user using messaging sending methods.
define('MESSAGING_TYPE_PUSH', 1);

function admin_messaging_help($path, $arg) {
    if ($path == 'admin/help#admin_messaging') {
        $txt = 'This module provides a way for an administrator '.
            'to send messages to user. '.
	    'using optional sending methods.'.
            'It assumes that Drupal mailer is configured.';
        return '<p>'.t($txt).'</p>';
    }
}

/**
 * Implementation of hook_perm().
 */
function admin_messaging_perm() {
  return array('administer admin_messaging', 'send messages to users', 'administer multiple messages');
}

/**
* Implementation of hook_menu()
*/
function admin_messaging_menu() {
    // User ID must pass:
    //$items = array();
   $items['user/%user/compose'] = array(
        'title' => 'Admin Messaging',
        'page callback' => 'admin_messaging_compose',
        'page arguments' => array(1), // <- userID (from % in node path)
        'access arguments' => array('administer users'),
        'type' => MENU_LOCAL_TASK,
    );  
   $items['admin/settings/admin-messaging-multiple'] = array(
    'title' => 'Admin Messaging',
    'description' => 'Send Message To Users.',
    'page callback' => 'admin_messaging_multiple_compose',
    'page arguments' => array('admin_messaging_multiple_form'),
    'access arguments' => array('send messages to users'),
    'file' => 'admin_messaging.admin.inc',
   );
        // Auto-completes available user names & removes duplicates.
    $items['admin/settings/admin_messaging_multiple_autocomplete'] = array(
       //'title' => 'Multiple Messaging',
       'page callback'    => 'admin_message_multiple_autocomplete',
       'access arguments' => array('administer multiple messages'),
       'file' => 'admin_messaging.admin.inc',
      // 'type'             => MENU_CALLBACK,
       'weight'           => -10,
  );
  return $items;
}
/**
 * Implementation of hook_user().
 */
function admin_messaging_user($op, &$edit, &$account, $category) {
   if ($op == 'view' && user_access('administer admin_messaging')) {
       // Create the outer "block"
        $account->content['admin_messaging'] = array(
            '#type' => 'user_profile_category',
            '#attributes' => array('class' => 'user-member'),
            '#weight' => 0,
            '#title' => t(''),
        ); 
    } 
}

/**
 * Form constructor function with the fields interface
 */
function admin_messaging_compose_form($context, $account) {
    // This is a value only -- equivalent to a hidden field, except
    // that it is never rendered into the HTML.
    $form['to'] = array(
        '#type' => 'value',
        '#value' => $account,
    );   
    // This creates a fieldset for the body:
    $form['message'] = array(
        '#type' => 'fieldset',
        '#title' => t('Compose New Message'),
    );

    // Textfield for subject of the body
    $form['message']['subject'] = array(
        '#type' => 'textfield',
        '#title' => t('Subject'),
        '#size' => 50,
        '#maxlengh' => 255,
        '#required' => true,
        '#description' => t('The subject of the message.'),
    );
    // Text area for the body.
    $form['message']['body'] = array(
        '#type' => 'textarea',
        '#title' => t('Message'),
        '#cols' => 50,
        '#rows' => 5,
        '#required' => true,
        '#description' => t('The body of the message.'),
    );
    // Creates a fieldset for details
    // $form['details'] = array(
        // '#type' => 'fieldset',
        // '#title' => t("Details"),
    // );
    // Creates a fieldset for sending options
	$method_list = messaging_method_list();
	$method_list['debug'] = 'Debug';
	$method_list['user'] = 'User Prefered';
	$form['method'] = array (
		'#type' => 'select' ,
		'#title' => t('Select Sending Method') ,
		 '#rows' => 5 ,
		'#options' => $method_list, //the option list called from the messaging list, alternate '#options' => array(email => 'Email', web => 'Web') ),
		'#default_value' => messaging_method_default(),
	) ;
  // submit button:
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Send Message'),
  );
  return $form;
}

/**
 * Compose a message.
 * Creating form neccessary to compose message.
 *
 * @param $to
 *  The address to send to.
 * @return
 *  HTML.
 */
function admin_messaging_compose($user) {
    if ($user->uid <= 0)
        return t('User ID must be an integer.');
    $account = $user;
    if (empty($account))
        return t('No such user found.');
    $to = $account->mail;
    $sb = '<p>'
        .t('Send message to user', array('@email' => $to))
        .'</p>';
    $sb .= drupal_get_form('admin_messaging_compose_form', $account);
    return $sb;
}

/**
 * Compose a message.
 * Creating form neccessary to compose message for.
 * To be send to multiple users.
 * @param $to
 *  The address to send to.
 * @return
 *  HTML.
 */
function admin_messaging_multiple_compose($user) {
global $user;      
// Generate the list of addresses that this e-mail will be sent to.
      $addresses = array_filter(explode(',', $email['email']));
      $addresses_final = array();
      foreach ($addresses as $address) {
        $address = trim($address);
	}
//foreach ($account as $account)
    $account = $user;
    $to = $account->mail;
    $sb = '<p>'
        .t('Send message to user', array('@email' => $to))
        .'</p>';
    $sb .= drupal_get_form('admin_messaging_multiple_form', $account);
    return $sb;
}

/**
 * @}
 */

/**
 * Return autocomplete results for usernames.
 *
 * Prevents usernames from being used and/or suggested twice.
 */
function admin_message_multiple_autocomplete($string) {
$names = array();
  // Building list of valid user names.
  $fragments = explode(',', $string);
  foreach ($fragments as $index => $name) {
    if ($name = trim($name)) {
      $names[$name] = $name;
    }
  }
  // Finding next user name suggestion.
  $fragment = array_pop($names);
  $matches = array();
  if (!empty($fragment)) {
    $query = admin_messaging_multiple_query('autocomplete', $fragment, $names);
    $result = db_query_range($query['query'], $fragment, 0, 10);
    $prefix = count($names) ? implode(", ", $names) .", " : '';
    while ($user = db_fetch_object($result)) {
      $matches[$prefix . $user->name .", "] = $user->name;
    }
  }
    drupal_json((object)$matches);
}
 
/**
 * Form submission handler for constructor function admin_messaging_compose_form()
 */
function admin_messaging_compose_form_submit($form, &$form_state) {
	//print_r($form_state);
  // $acount = user_load($form_state['values']['to']->uid);
  $form_values = $form_state['values'];
  $account = $form_state['values']['to'];
  $body = split("\n", $form_state['values']['body']);
  $body = array_map('trim', $body);  
  $message = array (
    'type' => 'push',
    'subject' => $form_state['values']['subject'],
		'body' => $body,  
  );
	
	// If method defined force sending method
	if ($form_state['values']['method'] != 'user')
		$method = $form_state['values']['method'];
	else
		$method = null;	
	
	// Set redirect page
  $form_state['redirect'] = sprintf('user/%d', $account->uid);
	
	// send message if user set
  if ($account) {
		$result = messaging_message_send_user($account, $message, $method);
	}
   drupal_set_message(t('Sent message with result: %result', array('%result' => $result ? 'OK' : 'Error'))); /**/
}


/**
 * Generates a query based on a query id.
 *
 * @param $query
 *   Either be a string ('some_id') or an array('group_name', 'query_id'),
 * @return
 *    Array with the keys query and count. count can be used to count the
 *    elements which would be returned by query. count can be used together
 *    with pager_query().
 *
 * @ingroup sql
 */
function admin_messaging_multiple_query($query) {
  if (is_array($query)) {
    $query_id = $query[0];
    $query_group = $query[1];
  }
  else {
    $query_id = $query;
    $query_group = 'privatemsg';
  }

  $SELECT = array();
  $INNER_JOIN = array();
  $WHERE = array();
  $GROUP_BY = array();
  $HAVING   = array();
  $ORDER_BY = array();
  $QUERY_ARGS = array('select' => array(), 'where' => array(), 'join' => array(), 'having' => array());
  $primary_table = '';

  $fragments = array(
    'select'      => $SELECT,
    'inner_join'  => $INNER_JOIN,
    'where'       => $WHERE,
    'group_by'    => $GROUP_BY,
    'having'      => $HAVING,
    'order_by'    => $ORDER_BY,
    'query_args'  => $QUERY_ARGS,
    'primary_table'  => $primary_table,
  );

  /**
   * Begin: dynamic arguments
   */
  $args = func_get_args();
  unset($args[0]);
  // we do the merge because we call call_user_func_array and not drupal_alter
  // this is necessary because otherwise we would not be able to use $args correctly (otherwise it doesnt unfold)
  $alterargs = array(&$fragments);
  $query_function = $query_group .'_sql_'. $query_id;
  if (!empty($args)) {
    $alterargs = array_merge($alterargs, $args);
  }
  /**
   * END: Dynamic arguments
   */
  if (!function_exists($query_function)) {
    drupal_set_message(t('Query function %function does not exist', array('%function' => $query_function)), 'error');
    return FALSE;
  }
  call_user_func_array($query_function, $alterargs);

  array_unshift($alterargs, $query_function);
  call_user_func_array('drupal_alter', $alterargs);

  $SELECT = $fragments['select'];
  $INNER_JOIN = $fragments['inner_join'];
  $WHERE = $fragments['where'];
  $GROUP_BY = $fragments['group_by'];
  $HAVING   = $fragments['having'];
  $ORDER_BY = $fragments['order_by'];
  $QUERY_ARGS = $fragments['query_args'];
  $primary_table = $fragments['primary_table'];

  // pgsql has a case sensitive LIKE - replace it with ILIKE. see http://drupal.org/node/462982
  if ($GLOBALS['db_type'] == 'pgsql') {
    $WHERE = str_replace('LIKE', 'ILIKE', $WHERE);
  }

  if (empty($primary_table)) {
    $primary_table = '{privatemsg} pm';
  }

  // Perform the whole query assembly only if we have something to select.
  if (!empty($SELECT)) {
    $str_select = implode(", ", $SELECT);
    $query = "SELECT {$str_select} FROM ". $primary_table;

    // Also build a count query which can be passed to pager_query to get a "page count" as that does not play well with queries including "GROUP BY".
    // In most cases,  "COUNT(*)" is enough to get the count query, but in queries involving a GROUP BY, we want a count of the number of groups we have, not the count of elements inside each group.
    // So we test if there is GROUP BY and if there is, count the number of distinct groups. If not, we go the normal wal and do a plain COUNT(*).
    if (!empty($GROUP_BY)) {
      // PostgreSQL does not support COUNT(sometextfield, someintfield), so I'm only using the first one
      // Works fine for thread_id/list but may generate an error when a more complex GROUP BY is used.
      $str_group_by_count = current($GROUP_BY);
      $count = "SELECT COUNT(DISTINCT {$str_group_by_count}) FROM ". $primary_table;
    }
    else {
      $count = "SELECT COUNT(*) FROM ". $primary_table;
    }

    if (!empty($INNER_JOIN)) {
      $str_inner_join = implode(' ', $INNER_JOIN);
      $query .= " {$str_inner_join}";
      $count .= " {$str_inner_join}";
    }
    if (!empty($WHERE)) {
      $str_where = '('. implode(') AND (', $WHERE) .')';
      $query .= " WHERE {$str_where}";
      $count .= " WHERE {$str_where}";
    }
    if (!empty($GROUP_BY)) {
      $str_group_by = ' GROUP BY '. implode(", ", $GROUP_BY) ;
      $query .= " {$str_group_by}";
    }
    if (!empty($HAVING)) {
      $str_having = '('. implode(') AND (', $HAVING) .')';
      $query .= " HAVING {$str_having}";
      // queries containing a HAVING break the count query on pgsql.
      // In this case, use the subquery method as outlined in http://drupal.org/node/303087#comment-1370752 .
      // The subquery method will work for all COUNT queries, but it is thought to be much slower, so we are only using it where other cross database approaches fail.
      $count = 'SELECT COUNT(*) FROM ('. $query .') as count';
    }
    if (!empty($ORDER_BY)) {
      $str_order_by = ' ORDER BY '. implode(", ", $ORDER_BY) ;
      $query .= " {$str_order_by}";
    }
    $QUERY_ARGS = array_merge($QUERY_ARGS['select'], $QUERY_ARGS['join'], $QUERY_ARGS['where'], $QUERY_ARGS['having']);
    if (!empty($QUERY_ARGS)) {
      _db_query_callback($QUERY_ARGS, TRUE);
      $query = preg_replace_callback(DB_QUERY_REGEXP, '_db_query_callback', $query);
      _db_query_callback($QUERY_ARGS, TRUE);
      $count = preg_replace_callback(DB_QUERY_REGEXP, '_db_query_callback', $count);
    }
    return array('query' => $query, 'count' => $count);
  }
  return FALSE;
}



